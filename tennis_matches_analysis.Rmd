---
title: "Analiziranje rezultata teniskih mečeva"
author: "Luka Raić, Anđelko Prskalo, Martin-Ante Rogošić, Katarina Zec"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    highlight: tango
toc-title: "Sadržaj"
documetclass: article
classoption: a4paper
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(dplyr)
library(purrr)
library(lubridate)
library(stringr)
library(dunn.test)
library(car)
```

# Definicija zajednički korištenih podataka i funkcija:

Funkcije za dohvat podataka i željenog perioda:

```{r}
fetch_data <- function(years) {
  
  df_list <- list()
  for (year in years) {
    file_path <- paste0("./ATP-Matches/atp_matches_", year, ".csv")
    if (file.exists(file_path)) {
      df <- 
        read_csv(file_path, col_types = 
                   "cccnccnnncccncnnncccncncncnnnnnnnnnnnnnnnnnnnnnnn", 
                 show_col_types = FALSE)
      df_list[[as.character(year)]] <- df
    } else {
      warning(paste("File not found for year", year))
    }
  }

  matches <- bind_rows(df_list)
  rm(df_list, file_path, df, year, years)

  matches  
}
```


# 1. istrazivačko pitanje: Kakva je distribucija mečeva na specifičnim podlogama u različitim godišnjim dobima?

U ovom istraživačkom pitanju ćemo koristiti podatke iz perioda 1968-2023. Za početak, dohvatimo potrebne podatke, uklonimo neregularne obzervacije (one mečeve za koje ne znamo na kojoj podlozi su odigrani) te pretvorimo datume u objekte tipa "date":

```{r}
matches <- fetch_data(1968:2023)

matches <- filter(matches, !is.na(surface))
matches$tourney_date <- ymd(matches$tourney_date)
```

Kako bismo odredili u kojem godišnjem dobu je odigran meč, za to kreiramo specifičnu funkciju "getSeason()": 

```{r}
getSeason <- function(DATES) {
    WS <- as.Date("2012-12-15", format = "%Y-%m-%d") # Winter Solstice
    SE <- as.Date("2012-3-15",  format = "%Y-%m-%d") # Spring Equinox
    SS <- as.Date("2012-6-15",  format = "%Y-%m-%d") # Summer Solstice
    FE <- as.Date("2012-9-15",  format = "%Y-%m-%d") # Fall Equinox

    d <- as.Date(strftime(DATES, format="2012-%m-%d"))

    ifelse (d >= WS | d < SE, "Winter",
      ifelse (d >= SE & d < SS, "Spring",
        ifelse (d >= SS & d < FE, "Summer", "Fall")))
}

matches$season <- getSeason(matches$tourney_date)
```

Sada kada imamo sve potrebne informacije za svaki meč, još nam jedino ostaje vizualizacija i pregled rezultata:

```{r}
ggplot(matches, aes(x = surface)) +
  geom_bar() + theme_bw() +
   facet_wrap(season ~ ., nrow = 2, ncol = 2) +
    labs(title = "Distribution of Matches on Specific Surfaces in Different Seasons", 
     x = "Surface", y = "Number of Matches")  

```
 
Zbog hladnog vremena zimi se većina mečeva igra u zatvorenim prostorima na tvrdoj podlozi i tepihu, u proljeće dominira šljaka na kojoj se između ostalog između sredine svibnja i ranog lipnja u Parizu održava French Open, ljeti su podjednako zastupljene šljaka i tvrda podloga s tim da se naglo povećava i broj mečeva na travi na kojoj se između ostalog u to vrijeme igra i famozni Wimbeldon, dok u jesen opet dominira tvrda podloga na kojoj se krajem kolovoza igra US Open.

# 2. istraživačko pitanje: Postoji li značajna razlika u prosječnom broju dvostrukih pogrešaka između mečeva odigranih na otvorenom u odnosu na mečeve odigrane na zatvorenom terenu?

## Postavljanje problema

Prvi problem u riješavanju ovog zadatka bila je kategorizacija mečeva na one igrane na otvorenom i one igrane na zatvorenom terenu, budući da dataset nije sadržavao tu specifičnu kategoriju podataka. Odlučili smo se za pristup koji svrstava mečeve u one na otvorenom ili zatvorenom terenu, na temelju podloge na kojoj su odigrani. Nakon toga moramo analizirati svojstva ovih dviju distribucija. Dobijemo li da se distribucije ponašaju jednako zaključujemo da ne postoji značajna razlika u broju dvostrukih pogrešaka među mečevima odigranima na zatvorenim i otvorenim terenima. U suprotnom pokazat cemo da razlika postoji.

## Priprema podataka

Podatke smo pripremili tako da smo čitav skup podataka spojili u podatkovni okvir, iz tog okvira izbacili smo sve stupce koji nas ne zanimaju u kontekstu ovog zadatke (sve osim podloge i broja dvostrukih pogrešaka za oba igrača). U sljedećem koraku izbacili smo svaki meč za kojeg svi relevantni podatci nisu definirani. Konačno dodali smo novi stupac u podatkovni okvir koji predstavlja ukupan broj dvostrukih grešaka za pojedini meč. Upravo je ukupan broj dvostrukih pogrešaka podatak kojeg želimo analizirati. Originalni podatkovni okvir sada razdvajamo na 4 podatkovna okvira, jedan za svaku vrstu podloge. Zaključili smo da je najbolji način za odrediti jeli meč igran na otvorenom ili zatvorenom terenu jest gledati na kojoj je podlozi igran. Procjenili smo da su podloge ilovine i trave karakteritične za vanjske terene dok tu tepisi i tvrde podloge karakteristični za zatvorene. Tako odredivši kategorizaciju spojili smo podatkovne okvire, nakon čega su nam preostala dva okvira, jedan za mečeve odigrane na otvorenom i jedan za one odigrane na zatvorenom terenu.

```{r}
fileList <- list.files(path = "./ATP-Matches/", pattern = "\\.csv", full.names = TRUE)
combined_data <- data.frame()
for(file in fileList){
  temp <- read.csv(file, header = TRUE)
  combined_data <- rbind(combined_data, temp)
  
}

unique_tournaments <- unique(combined_data$tourney_name)

combined_data <- subset(combined_data, select = c("surface", "l_df", "w_df"))

combined_data <- na.omit(combined_data)

combined_data$combined_df <- combined_data$l_df + combined_data$w_df

hard_surface <- subset(combined_data, surface == "Hard")
carpet_surface <- subset(combined_data, surface == "Carpet")
clay_surface <-subset(combined_data, surface == "Clay")
grass_surface <- subset(combined_data, surface == "Grass")

outdoor_tournaments <- rbind(clay_surface,grass_surface)
indoor_tournaments <- rbind(carpet_surface, hard_surface)
```

## Deskriptivna statistika

Kako bismo dobili bolju intuiciju za distribucije varijabli, pogledajmo histograme mečeva 

```{r, fig.show='asis'}


par(mfrow = c(1, 2))

hist(outdoor_tournaments$combined_df, border = "black", col = "lightblue", main = "Otvoreni tereni") 

hist(indoor_tournaments$combined_df, border = "black", col = "lightblue", main = "Zatvoreni tereni")

```

Uočimo da je izgled dvaju histograma dosta sličan. Distribucija na prvi pogled izgleda kao eksponencijalna, međutim prvi stupac histograma kvari taj obrazac, pogledajmo izgled histograma jednom kad normaliziramo varijable kako bismo potencijalno dobili nešto smislenije.

```{r}
normalized_outdoor_tournaments <- scale(outdoor_tournaments$combined_df)
normalized_indoor_tournaments <- scale(indoor_tournaments$combined_df)

par(mfrow = c(1, 2))

hist(normalized_outdoor_tournaments, border = "black", col = "lightblue", main = "Otvoreni tereni", )

hist(normalized_indoor_tournaments, border = "black", col = "lightblue", main = "Zatvoreni tereni")
```

Kao što vidimo distribucija vrijednosti nije normalna niti odgovara nekoj opće poznatoj distribuciji. Distribucija je donekle simetrična i vidimo da je nagnuta na lijevu stranu. Ako nas zanima koliko blisko su ove dvije disribucije normalnoj možemo provjeriti upotrebom qq plota,

```{r}
par(mfrow = c(1, 2))
qqnorm(normalized_indoor_tournaments)
qqline(normalized_indoor_tournaments)


qqnorm(normalized_outdoor_tournaments)
qqline(normalized_outdoor_tournaments)
```

## Prediktivna statistika

Jasno je da su podatci izričito nenormalni stoga će se za testiranje morati koristiti neparametarska metoda koja nije osjetljiva na normalnost distribucija koje promatramo. Dodatno s obzirom da proučavamo sredine uzoraka čije distribucije ne znamo, znamo da naš neparametarski test mora biti pandan parametarskom t-testu. Jedan od testova kojeg možemo koristiti je Mann-Whitney-Wilcoxonov.  Mann-Whitney-Wilcoxonov općenito testira tendenciju da jedna distribucija daje veće vrijednosti od druge distribucije,stoga je prikladan u ovom slučaju. Kao razinu značajnosti za naš statistički test uzeti ćemo standardnu razinu 0.05. Kao nultu hipotezu postaviti ćemo tezu: ne postoji razlika između broja dvostrukih grešaka između mečeva odigranih na otvorenom odnosno zatvorenom terenu. Kao alternativnu hipotezi postaviti ćemo da razlika postoji.


```{r}

wilcox.test(normalized_indoor_tournaments, normalized_outdoor_tournaments)

```

S obzirom da je p-vrijednost vrlo mala, na razini značajnosti od 0.05 možemo odbaciti nultu hipotezu u korist alternative te zaključiti da postoji značajna razlika u broju dvostrukih grešaka odigranih na otvorenom terenu u odnosu na one odigrane u zatvorenom terenu.

# 3. istraživačko pitanje: Ima li razlike u broju serviranih asova na različitim podlogama?

## Učitavanje podataka

Podatke ćemo učitati iz CSV datoteka u listu podatkovnih okvira. Svaki podatkovni okvir sadržava podatke mečeva jedne godine. Nakon toga spajamo sve podatkove okvire u jedan te time imamo informacije o svim odigranim mečevima od 1968. do 2023. godine dostupne u jednom podatkovnom okviru. Iz tog okvira ćemo naknadno izvlačiti potrebne podatke za svrhe analize.

Proces učitavanja podataka je prikazan u sljedećem bloku koda:

```{r}
matches <- fetch_data(1968:2023)
```

## Prilagodba tipova podataka

Nakon učitavanja podataka, potrebno je ispraviti tipove podataka za neke stupce. Ti stupci su:

* `surface` - podloga na kojoj se igrao meč: trava, zemlja, tvrda podloga, tepih (eng. grass, clay, hard, carpet)
* `tourney_level` - razina turnira: Grand Slam, ATP Finals, ATP Masters 1000, ATP Tour, ATP Challengers
* `tourney_date` - datum održavanja turnira
* `winner_hand` - ruka s kojom je pobjednik igrao meč: desnoruk, lijevoruk, ambidekster, nepoznato (eng. right-handed ("R"), left-handed ("L"), ambidextrous ("A"), unknown ("U"))
* `loser_hand` - ruka s kojom je gubitnik igrao meč (definirano isto kao i za winner_hand)

Prilagodba tipova podataka je prikazana u sljedećem kodu:

```{r}
matches$surface <- factor(
  matches$surface,
  levels = c("Grass", "Clay", "Hard", "Carpet")
)
matches$tourney_level <- factor(
  matches$tourney_level,
  levels = c("F", "A", "D", "M", "G")
)
matches$tourney_date <- ymd(matches$tourney_date)
matches$winner_hand <- factor(
  matches$winner_hand,
  levels = c("R", "L", "A", "U")
)
matches$loser_hand <- factor(
  matches$loser_hand,
  levels = c("R", "L", "A", "U")
)
```

## Statistička analiza

### Priprema podataka

Za provođenje statističke analize, potrebno je pripremiti podatke. U ovom slučaju, potrebno je izvući podatke o broju serviranih asova po meču i podlogama na kojima se igrao meč. Također, potrebno je ukloniti sve mečeve koji nemaju podatak o broju serviranih asova ili podlogama na kojima se igrao meč.

Podatke spremamo u nove podatkovne okvire od kojih svaki predstavlja aseve na jednoj podlozi:

```{r}
# izdvajanje broja serviranih asova na travnatoj podlozi
aces_grass <- matches %>%
  filter(!is.na(w_ace) & !is.na(l_ace) & surface == "Grass") %>%
  mutate(aces = w_ace + l_ace) %>%
  dplyr::select(aces)

# izdvajanje broja serviranih asova na zemljanoj podlozi
aces_clay <- matches %>%
  filter(!is.na(w_ace) & !is.na(l_ace) & surface == "Clay") %>%
  mutate(aces = w_ace + l_ace) %>%
  dplyr::select(aces)

# izdvajanje broja serviranih asova na tvrdoj podlozi
aces_hard <- matches %>%
  filter(!is.na(w_ace) & !is.na(l_ace) & surface == "Hard") %>%
  mutate(aces = w_ace + l_ace) %>%
  dplyr::select(aces)

# izdvajanje broja serviranih asova na tepihu
aces_carpet <- matches %>%
  filter(!is.na(w_ace) & !is.na(l_ace) & surface == "Carpet") %>%
  mutate(aces = w_ace + l_ace) %>%
  dplyr::select(aces)

# izdvajanje broja serviranih asova na svim podlogama
aces_all <- matches %>%
  filter(!is.na(w_ace) & !is.na(l_ace) & !is.na(surface)) %>%
  mutate(aces = w_ace + l_ace) %>%
  dplyr::select(aces)
```

### Deskriptivna statistika

Sada kada smo pripremili podatke, možemo izračunati deskriptivnu statistiku za broj serviranih asova po podlogama. Za svaku podlogu, izračunat ćemo sljedeće vrijednosti za svaku od podloga:

* prosjecni broj asova
* standardnu devijaciju broja asova
* medijan broja asova
* minimalni broj asova
* maksimalni broj asova
* broj mečeva

```{r, echo=FALSE}
# deskriptivna statistika za broj serviranih asova na svakoj od podloga
aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  bind_rows(aces_all %>%
    mutate(surface = "Ukupno")) %>%
  group_by(surface) %>%
  summarise(
    mean = mean(aces),
    sd = sd(aces),
    median = median(aces),
    min = min(aces),
    max = max(aces),
    count = n()
  ) %>%
  arrange(count) %>%
  knitr::kable(
    caption = "Servirani asovi po podlogama",
    digits = 2
  )
```

Iz prikazanih vizualizacija, možemo vidjeti kako je, u prosijeku, najviše asova servirano na travi, a najmanje na zemlji. Također, možemo vidjeti kako je na travi servirano najviše asova u jednom meču, a na tepihu najmanje. Najveću varijancu broja serviranih asova po meču imamo na travi.

Ove podatke možemo vizualizirati pomoću boxplot dijagrama i dijagrama gustoće.

```{r, echo=FALSE}
# boxplot dijagrami za broj serviranih asova na svakoj od podloga
aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  ggplot(aes(x = aces, y = surface)) +
  geom_boxplot() +
  labs(
    title = "Broj serviranih asova po podlogama",
    x = "Broj serviranih asova",
    y = "Podloga"
  )
```
```{r, echo=FALSE}
# dijagrami gustoće za broj serviranih asova na svakoj od podloga
aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  ggplot(aes(x = aces, fill = surface)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~surface, ncol = 2) +
  labs(
    title = "Broj serviranih asova po podlogama",
    x = "Broj serviranih asova",
    y = "Gustoća"
  )
```

Iz prikazanih boxplot dijagrama i dijagrama gustoće možemo vidjeti kako je distribucija svih uzoraka jako nakošena u lijevo što znači da je većina uzoraka blizu minimalne vrijednosti.

Kako bismo pokušali normalizirati distribucije, možemo izbaciti sve observacije s vrijednostima izvan 1.5 interkvartilnog raspona (outlier-e).

```{r, echo=FALSE}
# izbacivanje outlier-a
aces_grass <- aces_grass %>%
  filter(
    aces >= quantile(aces, 0.25) - 1.5 * IQR(aces) &
      aces <= quantile(aces, 0.75) + 1.5 * IQR(aces)
  )

aces_clay <- aces_clay %>%
  filter(
    aces >= quantile(aces, 0.25) - 1.5 * IQR(aces) &
      aces <= quantile(aces, 0.75) + 1.5 * IQR(aces)
  )

aces_hard <- aces_hard %>%
  filter(
    aces >= quantile(aces, 0.25) - 1.5 * IQR(aces) &
      aces <= quantile(aces, 0.75) + 1.5 * IQR(aces)
  )

aces_carpet <- aces_carpet %>%
  filter(
    aces >= quantile(aces, 0.25) - 1.5 * IQR(aces) &
      aces <= quantile(aces, 0.75) + 1.5 * IQR(aces)
  )

aces_all <- aces_all %>%
  filter(
    aces >= quantile(aces, 0.25) - 1.5 * IQR(aces) &
      aces <= quantile(aces, 0.75) + 1.5 * IQR(aces)
  )
```
```{r, echo=FALSE}
# deskriptivna statistika za broj serviranih asova na svakoj od podloga nakon izbacivanja outlier-a
aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  group_by(surface) %>%
  summarise(
    mean = mean(aces),
    sd = sd(aces),
    median = median(aces),
    min = min(aces),
    max = max(aces),
    count = n()
  ) %>%
  knitr::kable(
    caption = "Servirani asovi po podlogama nakon izbacivanja outlier-a",
    digits = 2
  )
```
```{r, echo=FALSE}
# boxplot dijagrami za broj serviranih asova na svakoj od podloga nakon izbacivanja outlier-a
aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  ggplot(aes(x = aces, y = surface)) +
  geom_boxplot() +
  labs(
    title = "Broj serviranih asova po podlogama nakon izbacivanja outlier-a",
    x = "Broj serviranih asova",
    y = "Podloga"
  )
```
```{r, echo=FALSE}
# dijagrami gustoće za broj serviranih asova na svakoj od podloga nakon izbacivanja outlier-a
aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  ggplot(aes(x = aces, fill = surface)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~surface, ncol = 2) +
  labs(
    title = "Broj serviranih asova po podlogama nakon izbacivanja outlier-a",
    x = "Broj serviranih asova",
    y = "Gustoća"
  )
```

Nakon izbacivanja outlier-a, distribucije su i dalje nakošene u lijevo, ali je to manje izraženo nego prije. Također možemo vidjeti kako je sada varijanca svake podloge manja nego prije.

### Statističko testiranje

Nakon vizualiziranja podataka i izbacivanja outlier-a, možemo provesti statističko testiranje. Budući da distribucije uzoraka ne izgledaju kao da potječu iz normalne distribucije, prvo ćemo provjeriti njihovu normalnost, a zatim na temelju ishoda testa odlučiti koji test ćemo koristiti za provođenje statističkog testiranja.

#### Testiranje normalnosti

Za testiranje normalnosti koristit ćemo Kolmogorov-Smirnovljev test. Testirat ćemo normalnost svih uzoraka zajedno, a zatim svakog uzorka posebno.

Prije testiranja, postavljamo hipoteze:

* H0: distribucija uzorka je normalna
* H1: distribucija uzorka nije normalna

Za razinu značajnosti uzimamo 0.05.

```{r, echo=FALSE, warning=FALSE}
# testiranje normalnosti svih uzoraka zajedno
ggplot(
  data = aces_all,
  aes(x = aces)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(aces_all$aces), sd = sd(aces_all$aces)),
    color = "red"
  ) +
  labs(x = "Broj serviranih asova", y = "CDF") +
  ggtitle("Servirani asovi na svim podlogama") +
  theme_bw()
ks.test(
  aces_all$aces,
  "pnorm",
  mean = mean(aces_all$aces),
  sd = sd(aces_all$aces)
)

# testiranje normalnosti uzorka travnate podloge
ggplot(
  data = aces_grass,
  aes(x = aces)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(aces_grass$aces), sd = sd(aces_grass$aces)),
    color = "red"
  ) +
  labs(x = "Broj serviranih asova", y = "CDF") +
  ggtitle("Servirani asovi na travnatoj podlozi") +
  theme_bw()
ks.test(
  aces_grass$aces,
  "pnorm",
  mean = mean(aces_grass$aces),
  sd = sd(aces_grass$aces)
)

# testiranje normalnosti uzorka zemljane podloge
ggplot(
  data = aces_clay,
  aes(x = aces)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(aces_clay$aces), sd = sd(aces_clay$aces)),
    color = "red"
  ) +
  labs(x = "Broj serviranih asova", y = "CDF") +
  ggtitle("Servirani asovi na zemljanoj podlozi") +
  theme_bw()
ks.test(
  aces_clay$aces,
  "pnorm",
  mean = mean(aces_clay$aces),
  sd = sd(aces_clay$aces)
)

# testiranje normalnosti uzorka tvrde podloge
ggplot(
  data = aces_hard,
  aes(x = aces)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(aces_hard$aces), sd = sd(aces_hard$aces)),
    color = "red"
  ) +
  labs(x = "Broj serviranih asova", y = "CDF") +
  ggtitle("Servirani asovi na tvrdoj podlozi") +
  theme_bw()
ks.test(
  aces_hard$aces,
  "pnorm",
  mean = mean(aces_hard$aces),
  sd = sd(aces_hard$aces)
)

# testiranje normalnosti uzorka tepiha
ggplot(
  data = aces_carpet,
  aes(x = aces)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(aces_carpet$aces), sd = sd(aces_carpet$aces)),
    color = "red"
  ) +
  labs(x = "Broj serviranih asova", y = "CDF") +
  ggtitle("Servirani asovi na tepihu") +
  theme_bw()
ks.test(
  aces_carpet$aces,
  "pnorm",
  mean = mean(aces_carpet$aces),
  sd = sd(aces_carpet$aces)
)
```

Iz prikazanih dijagrama i rezultata testiranja možemo vidjeti kako distribucije uzoraka nisu normalne. Stoga ćemo za statističko testiranje koristiti neparametarske testove.

#### Neparametarsko testiranje

Za neparametarsko testiranje koristit ćemo Kruskal-Wallisov test. Prije testiranja, postavljamo hipoteze:

* H0: nema razlike u broju serviranih asova na različitim podlogama
* H1: postoji razlika u broju serviranih asova na različitim podlogama

Za razinu značajnosti uzimamo 0.05.

```{r, echo=FALSE}
aces <- aces_grass %>%
  mutate(surface = "Travnata") %>%
  bind_rows(aces_clay %>%
    mutate(surface = "Zemljana")) %>%
  bind_rows(aces_hard %>%
    mutate(surface = "Tvrda")) %>%
  bind_rows(aces_carpet %>%
    mutate(surface = "Tepih")) %>%
  dplyr::select(aces, surface)

# Kruskal-Wallisov test za broj serviranih asova na različitim podlogama
kruskal.test(aces ~ surface, data = aces)
```

Iz rezultata testiranja možemo vidjeti kako je p-vrijednost manja od 0.05, stoga odbacujemo nultu hipotezu i zaključujemo kako postoji razlika u broju serviranih asova na različitim podlogama.

Kako bismo saznali na kojim podlogama postoji razlika u broju serviranih asova, provest ćemo post-hoc testiranje. Za post-hoc testiranje koristit ćemo Dunnov test. 

```{r, echo=FALSE}
# Dunnov test za broj serviranih asova na različitim podlogama
dunn.test(
  aces$aces,
  aces$surface,
  method = "bonferroni",
  alpha=0.05,
  kw = FALSE
)
```

Iz rezultata testiranja možemo vidjeti kako je p-vrijednost manja od 0.05 za sve kombinacije podloga, stoga odbacujemo nultu hipotezu za sve kombinacije podloga i zaključujemo kako postoji razlika u broju serviranih asova na svim kombinacijama podloga.

## Zaključak

Na temelju provedene statističke analize, možemo zaključiti kako postoji razlika u broju serviranih asova na različitim podlogama. Štoviše, postoji razlika u broju serviranih asova na svim kombinacijama podloga. Najviše asova servirano je na travi, a najmanje na zemlji. Također, najveća varijanca broja serviranih asova po meču je na travi, a najmanja na tepihu.

```{r, echo=FALSE, include=FALSE}
# oslobađanje memorije
rm(aces, aces_all, aces_carpet, aces_clay, aces_grass, aces_hard)
```

# 4. istraživačko pitanje: Kakva je veza između vrste terena i vjerojatnosti da će mečevi otići u 5. set?

Ovo pitanje možemo riješiti pomoću hi-kvadrat testa homogenosti, s tim da moramo paziti da određene pretpostavke budu zadovoljene. Kako bismo to mogli provjeriti, prvo moramo izolirati željene podatke u obliku pogodnom za obradu. Za početak, idemo učitati sve potrebne podatke:

```{r}
matches <- fetch_data(1968:2023)
matches <- matches[, c("surface", "score", "best_of")]
```

Zatim moramo eliminirati neregularne obzervacije: mečeve za koje ne znamo podlogu na kojoj su odigrani i/ili mečevi u kojima teoretski nije bilo moguće odigrati 5 setova (zbog samog formata natjecanja):

```{r}
matches %>% filter(!is.na(surface), best_of == 5) -> matches
matches$best_of <- NULL
```

Sada dijelimo mečeve u 2 skupa: oni u kojima je odigrano svih 5 setova i oni u kojima nije (NAPOMENA: u ovom 2. slučaju pritom ignoriramo mečeve koji su otkazani zbog neprimjerenog ponašanja igrača, pogreške sudca u organizacijskom smislu, zbog loših vremenskih uvjeta i raznih drugih okolnosti koje "nisu vezane uz sam sport"):

```{r}
fiveSetMatchesIndices <- which(
  !str_detect(matches$score, "[^0-9- ]") & str_count(matches$score, "-") == 5)
fiveSetsMatches <- matches[fiveSetMatchesIndices, ]

lessThanFiveSetsMatches <- matches[-fiveSetMatchesIndices, ]
lessThanFiveSetsMatches <- filter(lessThanFiveSetsMatches, 
                                  !str_detect(score, "(Played and unfinished|Played and abandoned|W/O|UNK|DEF|Default)"))
```

Sada gradimo kontingencijsku tablicu:

```{r}
fiveSetsMatches %>% group_by(surface) %>% summarise(count = n()) -> fiveSetsMatches
lessThanFiveSetsMatches %>% group_by(surface) %>% summarise(count = n()) -> lessThanFiveSetsMatches

data <- as.table(rbind(pull(fiveSetsMatches, count), pull(lessThanFiveSetsMatches, count)))
colnames(data) <- c("Carpet", "Clay", "Grass", "Hard")
rownames(data) <- c("5 sets played", "Less than 5 sets played")
probabilities <- data[1, ] / data[2, ] 
```

Sada provodimo test i gledamo ispise:

```{r}
test <- chisq.test(data)
test$observed   
test$expected   
test$residuals  
test$stdres     
test
```

S obzirom na to da je vrijednost svake ćelije frekvencija, da svaka obzervacija pripada jednoj ćeliji te da je očekivana vrijednost svake ćelije >= 5, možemo zaključiti da su rezultati ovog testa validni te da vjerojatnost da će meč otići u 5. set ne ovisi o vrsti terena (jako mala P-vrijednost: 2.2e-16)

# 5. istraživačko pitanje: Možemo li procijeniti broj asova koje će igrač odservirati u tekućoj (zadnjoj dostupnoj sezoni) na temelju njegovih rezultata iz prethodnih sezona?

## Previđanje broja aseva u trenutnoj sezoni na temelju podataka iz prethodnih sezona

Statistika je jedna od glavnih znanosti koje se vežu uz sport. Jedan od najpoznatijih pojmova koji se vežu uz tenis je zasigurno pojam asa. Pojam označava uspješan servis pri kojem protivnik nije dotaknuo serviranu lopticu. Asevi su najsigurniji i gotovo najlakše dobiveni poeni u tenisu, gotovo poput zakucavanja u košarci.

Postavlja se pitanje: možemo li uz pomoć programskog jezika R i statistika o ATP mečevima od 1968. do 2022. godine predvidjeti koliko će aseva određeni igrač imati u tekućoj sezoni?

Pogledamo li dataframe s podacima nakon uvoza svih .csv datoteka, primjećujemo da se statistika o broju aseva po meču za pobjednika i gubitnika počela bilježiti tek 1991. godine. Stoga, kada uvozimo podatke, izuzimamo sve retke čija je vrijednost varijable w_ace ili l_ace jednaka NA.

```{r}
# Dohvaćanje popisa .csv datoteka u direktoriju
tennis_files <- list.files(path = "./ATP-Matches/", pattern = "\\.csv$", full.names = TRUE)

# Inicijalizacija praznog dataframe-a za čuvanje podataka
tennis_dataset <- data.frame()

# Iteracija kroz svaku .csv datoteku
for (datoteka in tennis_files) {
  # Učitavanje .csv datoteke
  podaci <- read.csv(datoteka)
  
  # Uklanjanje redova s NA vrijednostima u w_ace i l_ace
  podaci_bez_na <- podaci[complete.cases(podaci$w_ace, podaci$l_ace), ]
  
  # Dodavanje učitanih podataka u dataset
  tennis_dataset <- rbind(tennis_dataset, podaci_bez_na)
}

```

## Odabir potrebnih parametara

Da bismo mogli kreirati model višestruke linearne regresije, moramo znati koje od dostupnih varijabli utječu na traženu zavisnu varijablu.

Pogledamo li dostupne varijable iz zadanog dataseta, vidimo da možemo eliminirati podatke o identifikaciji meča, kao što su podaci o rundi turnira, rezultat, država iz koje igrač dolazi, način na koji je igrač došao na turnir...

Zadržat ćemo podatke o performansu igrača u meču:

-   broj aseva

-   dvostruke pogreške

-   uspješnih prvih i drugih servisa

-   dobivenih prvih servisa

-   serviranih gejmova

-   odigranih *breakova* i spašenih *breakova*

Informacije o visini i dominantnoj ruci igrača nećemo uzimati u obzir budući da, iako imaju utjecaj na servis igrača i samim time na broj aseva koje igrač postigne u karijeri, ostaju iste kroz karijeru pojedinca.

```{r}
# Kreirajte dataframe za pobjednike
winners <- tennis_dataset[, c("winner_id", "winner_name", "tourney_id", "surface",  "winner_age",  "winner_rank",  "w_ace", "w_df", "w_svpt", "w_1stIn", "w_1stWon", "w_2ndWon", "w_SvGms", "w_bpSaved", "w_bpFaced", "minutes" )]

colnames(winners) <- c("player_id", "name", "tour_id", "surface",  "age", "rank", "ace", "double_fault", "saved points", "1st serves made", "1st serves won", "2nd serves won", "served games", "saved breaks", "faced breaks", "minutes")

# Kreirajte dataframe za gubitnike
losers <- tennis_dataset[, c("loser_id", "loser_name", "tourney_id", "surface", "loser_age",  "loser_rank",  "l_ace", "l_df", "l_svpt", "l_1stIn", "l_1stWon", "l_2ndWon", "l_SvGms", "l_bpSaved", "l_bpFaced", "minutes" )]

colnames(losers) <- c("player_id", "name", "tour_id", "surface", "age", "rank", "ace", "double_fault", "saved points", "1st serves made", "1st serves won", "2nd serves won", "served games", "saved breaks", "faced breaks", "minutes")

all_players_stats <- rbind(winners, losers)

stats_per_player <- split.data.frame(all_players_stats, all_players_stats[["name"]])
```

## Izbor igrača na temelju čijih se podata izrađuje model

Nakon što smo napravili potrebne redukcije i transformacije na originalnom datasetu, dobili smo popis sa 2425 elemenata, tj. popis od 2425 igrača. Za svakog od njih imamo podatke o svim teniskim mečevima koje su odigrali u sklopu ATP turnira. Budući da ne možemo napraviti linearnu regresiju s malim brojem mečeva, izbacujemo sve igrače za koje imamo manje od 30 mečeva.

```{r}
reduced_stats_per_player <- Filter(function(dataset) nrow(dataset) >= 30, stats_per_player)
```

Nakon odabira igrača na temelju čijih podataka će se napraviti model linearne regresije, uvodimo novu varijablu "year" na temelju koje ćemo razdvojiti podatke u set za treniranje modela i set za testiranje modela.

Kao primjer uzet ćemo podatke za Davida Ferrera. David Ferrer je odabran primarno zbog velikog broja dostupnih podataka.

```{r}
player_stats <- subset(reduced_stats_per_player$`David Ferrer`)
```

```{r, echo = FALSE}
player_stats$year <- strtoi(substr(player_stats$tour_id, 1, 4))

last_available_season <- max(player_stats$year)

train_data <- subset(player_stats, year <= last_available_season)
test_data <- subset(player_stats, year == last_available_season)
```

Nakon podijele dostupnog dataseta na dva podseta koji će poslužiti za "trening" modela i kasnije testiranje istog, prelazimo na identifikaciju vrijednosti koje uistinu utječu na servis i broj aseva.

## Obrada parametara

Započnimo s uvođenjem dummy varijabli za kategorijsku varijablu surface:

```{r}
#Dummy varijable za surface
dummy_df <- data.frame(model.matrix(~ surface - 1, data = player_stats))
```

Prelazimo na ispitivanje koje od dostupnih varijabli uistinu utječu na broj aseva u sezoni. Pretpostavka je da će nam bitne biti isključivo varijable vezane uz uspješnost servisa, učestalost servisa, te uz vrstu podloge na kojoj se igra. Provjerimo također imaju li iskustvo i rang na ljestvici na kojem se igrač nalazi koorelaciju s brojem aseva u meču.

```{r}
linearnost_2serv <- lm(ace~train_data$`2nd serves won`, data = as.data.frame(train_data))
```

```{r, echo = FALSE}
linearnost_godina <- lm(ace~train_data$age, data = as.data.frame(train_data))

linearnost_ranga <- lm(ace~train_data$rank, data = as.data.frame(train_data))

linearnost_dvostrukih <- lm(ace~train_data$double_fault, data = as.data.frame(train_data))

linearnost_podloga <- lm(ace~train_data$surface, data = as.data.frame(train_data))

linearnost_1serv <- lm(ace~train_data$`1st serves made`, data = as.data.frame(train_data))

linearnost_1won <- lm(ace~train_data$`1st serves won`, data = as.data.frame(train_data))
linearnost_svg <- lm(ace~train_data$`served games`, data = as.data.frame(train_data))
```

```{r}
par(mfrow = c(2, 3))

plot(player_stats$`2nd serves won`, player_stats$ace) 
lines(player_stats$`2nd serves won`, linearnost_2serv$fitted.values, col='red')

plot(player_stats$`1st serves made`, player_stats$ace) 
lines(player_stats$`1st serves made`, linearnost_1serv$fitted.values, col='red')

plot(player_stats$`1st serves won`, player_stats$ace) 
lines(player_stats$`1st serves won`, linearnost_1won$fitted.values, col='red')

par(mfrow = c(2, 3))

plot(player_stats$age, player_stats$ace) 
lines(player_stats$age, linearnost_godina$fitted.values, col='red')


plot(player_stats$double_fault, player_stats$ace) 
lines(player_stats$double_fault, linearnost_dvostrukih$fitted.values, col='red')

plot(player_stats$`served games`, player_stats$ace) 
lines(player_stats$`served games`, linearnost_svg$fitted.values, col='red')

par(mfrow = c(1, 2))

plot(player_stats$rank, player_stats$ace) 
lines(player_stats$rank, linearnost_ranga$fitted.values, col='red')

```

Vidimo da, kao što je pretpostavljeno, podaci kao što su broj serviranih gejmova, broj uspješnih prvih servisa, broj osvojenih prvih servisa, broj drugih servisa, te dvostrukih pogrešaka imaju linearnu razdiobu u ovisnosti o broju aseva u meču.

Na dijagramima za rang i godine nije vidljiva značajna koorelacija, tako da te dvije varijable izbacujemo iz modela.

## Ispitivanje normalnosti reziduala

Budući da je jedan od uvjeta linearne regresije normalnost reziduala, provjeravamo reziduale jednostavnih linearnih regresija za svaku od potrebnih varijabli. Idealno, to se može napraviti korištenjem Kolmogorov-Smirnovljevog testa, no on je osjetljiv na velike uzorke. Ovdje su već na početku eliminirani svi igrači koji imaju manje od 30 odigranih mečeva, tako da normalnost nikako nećemo testirati Kolmogorov-Smirnovljevim testom.

Radi praktičnosti, koristimo histograme i provjeravamo oblikuju li reziduali zvonoliku krivulju:

```{r, echo = FALSE}
par(mfrow = c(2, 3))

hist((linearnost_1serv$residuals), main = "Reziduali prvog servisa")

hist((linearnost_1won$residuals), main = "Reziduali dobivenih prvih servisa")

hist((linearnost_2serv$residuals), main = "Reziduali dobivenih drugih servisa")

hist((linearnost_svg$residuals), main = "Reziduali serviranih gejmova")

hist((linearnost_dvostrukih$residuals), main = "Reziduali dvostrukih pogrešaka")
```

Vidimo da sve varijable daju zvonoliku krivulju uz poneke "repiće". Njih tretiramo izbacivanjem outliera iz seta podataka. To će nam omogućiti dobivanje boljeg modela višestruke regresije.

```{r, echo = FALSE}
outlier_removal <- function(x, t = 1.5) {
  q1 <- quantile(x, 0.25)
  q3 <- quantile(x, 0.75)
  iqr <- q3 - q1
  LB <- q1 - t * iqr
  UB <- q3 + t * iqr
  outliers <- x < LB | x > UB
  return(outliers)
}

used_vars <- c("1st serves made", "1st serves won", "2nd serves won", "double_fault", "served games")

# Apply the function to each numeric variable
outliers <- apply(player_stats[, used_vars], 2, outlier_removal)

# Identify rows with outliers in at least one variable
rows_with_outliers <- apply(outliers, 1, any)

# Remove rows with outliers
player_stats_no_outliers <- player_stats[!rows_with_outliers, ]

train_data <- subset(player_stats_no_outliers, year <= last_available_season)
test_data <- subset(player_stats_no_outliers, year == last_available_season)
```

```{r, echo = FALSE}
linearnost_2serv <- lm(ace~train_data$`2nd serves won`, data = as.data.frame(train_data))

linearnost_dvostrukih <- lm(ace~train_data$double_fault, data = as.data.frame(train_data))

linearnost_podloga <- lm(ace~train_data$surface, data = as.data.frame(train_data))

linearnost_1serv <- lm(ace~train_data$`1st serves made`, data = as.data.frame(train_data))

linearnost_1won <- lm(ace~train_data$`1st serves won`, data = as.data.frame(train_data))

linearnost_svg <- lm(ace~train_data$`served games`, data = as.data.frame(train_data))


par(mfrow = c(2, 3))

hist((linearnost_1serv$residuals), main = "Reziduali prvog servisa")

hist((linearnost_1won$residuals), main = "Reziduali dobivenih prvih servisa")

hist((linearnost_2serv$residuals), main = "Reziduali dobivenih drugih servisa")

hist((linearnost_svg$residuals), main = "Reziduali serviranih gejmova")

hist((linearnost_dvostrukih$residuals), main = "Reziduali dvostrukih pogrešaka")
```

## Kreiranje modela višestruke linearne regresije

Na temelju selektiranih podataka izrađujemo model višestruke regresije. Nakon dobivanja modela, procjenjujemo kvalitetu istog. Osim uobičajenih parametara kvalitete testa koje dobivamo korištenjem funkcije summary(), za procjenu modela linearne regresije koristimo i metodu najmanjih kvadrata (SSE) i srednju kvadratnu pogrešku (MSE).

```{r}
# Kreiranje modela na temelju podataka iz trening-seta
model_igraca <- lm(ace ~ train_data$surface + train_data$`1st serves made` + train_data$`1st serves won` + train_data$double_fault + train_data$`2nd serves won`+ train_data$`served games` , data = as.data.frame(train_data))

summary(model_igraca)

# Procjena performansi modela na test setu
predicted_aces_test <- predict(model_igraca, predicted_data = as.data.frame(test_data))
mse <- mean((test_data$ace - predicted_aces_test)^2)
sse <- ((test_data$ace - predicted_aces_test)^2)
print(paste("Mean Squared Error (MSE):", mse))
tail(paste("Squared Sum Error (SSE): ", sse))

qqnorm(residuals(model_igraca))
qqline(residuals(model_igraca))

plot(density(residuals(model_igraca)), main = "Density Plot of Residuals")
```

### Pokazatelji kvalitete modela

Da bi model bio dobar, vrijednosti SSE-a i MSE-a moraju biti što bliže nuli. Vidljivo je da, iako SSE uvelike varira u svojim vrijednostima, MSE ima relativno prihvatljiv rezultat od 7.71. Premda je ta brojka zadovoljavajuća, pogled na druge parametre modela ukazuje na činjenicu da odabrane nezavisne varijable nisu idealan pokazatelj kvalitete servisa igrača. Pogledamo li p-vrijednosti koeficijenata, vidimo da u slučaju Davida Ferrera možemo izbaciti dvostruke pogreške i broj serviranih gejmova iz modela.

### Prilagođavanje odabira parametara

Napravimo li model bez te dvije varijable, vidmo da se vrijednost MSE-a poveća na 9.16.

Još jedan pokazatelj kvalitete modela je višestruki R kvadrat i prilagođeni R kvadrat. Oni ukazuju na kvalitetu izabranih prediktora u modelu. Raspon im je od 0 do 1, gdje 1 ukazuje na bolje odabrane prediktore i model koji dobro predviđa tražene vrijednosti. Prilagođeni R kvadrat kažnjava nepotrebno dodane prediktore. Uistinu, nakon uklanjanja dvostrukih pogrešaka i serviranih gejmova iz modela, dobivamo bolju vrijednost R kvadrata.Ta vrijednost niti nakon uklanjanja nepotrebnih prediktora nije dobra, što ukazuje na činjenicu da postoje faktori koje nismo uključili u model.

```{r, echo = FALSE}
train_data <- subset(player_stats, year <= last_available_season)
to_test <- subset(player_stats, year == last_available_season)
```

```{r}
# Kreiranje modela na trening setu
model_igraca <- lm(ace ~ train_data$surface + train_data$`1st serves made` + train_data$`1st serves won` +  train_data$`2nd serves won`, data = as.data.frame(train_data))

summary(model_igraca)
```

```{r, echo = FALSE}
# Evaluacija performansi modela na test setu
predicted_aces_test <- predict(model_igraca, predicted_data = as.data.frame(test_data))
mse <- mean((test_data$ace - predicted_aces_test)^2)
sse <- ((test_data$ace - predicted_aces_test)^2)
print(paste("Mean Squared Error (MSE) na test setu:", mse))
tail(paste("Squared Sum Error (SSE) na test setu: ", sse))

qqnorm(residuals(model_igraca))
qqline(residuals(model_igraca))

plot(density(residuals(model_igraca)), main = "Density Plot of Residuals")
```

Osim parametara modela, gledamo i normalnost reziduala. Pogledamo li dijagram gustoće reziduala, vidimo da dobivamo zvonoliku krivulju, što ukazuje da su reziduali normalno distribuirani.

## Možemo li zaključiti da je linearnom regresijom moguće predvidjeti broj aseva u sezoni?

Premda bismo mogli na temelju dosadašnjih saznanja mogli zaključiti da je moguće predvidjeti broj aseva koje će igrač odigrati u tekućoj sezoni, provođenjem izračuna na temelju podataka nekog drugog igrača, na primjer Novaka Đokovića, dolazimo do saznanja da do sada korišteni model ne funkcionira za sve igrače jednako:

```{r}
player_stats <- subset(reduced_stats_per_player$`Novak Djokovic`)
```

```{r, echo = FALSE}
player_stats$year <- strtoi(substr(player_stats$tour_id, 1, 4))

last_available_season <- max(player_stats$year)

train_data <- subset(player_stats, year <= last_available_season)
test_data <- subset(player_stats, year == last_available_season)

outlier_removal <- function(x, t = 1.5) {
  q1 <- quantile(x, 0.25)
  q3 <- quantile(x, 0.75)
  iqr <- q3 - q1
  LB <- q1 - t * iqr
  UB <- q3 + t * iqr
  outliers <- x < LB | x > UB
  return(outliers)
}

used_vars <- c("1st serves made", "1st serves won", "2nd serves won", "double_fault", "served games")

# Apply the function to each numeric variable
outliers <- apply(player_stats[, used_vars], 2, outlier_removal)

# Identify rows with outliers in at least one variable
rows_with_outliers <- apply(outliers, 1, any)

# Remove rows with outliers
player_stats_no_outliers <- player_stats[!rows_with_outliers, ]

train_data <- subset(player_stats_no_outliers, year <= last_available_season)
test_data <- subset(player_stats_no_outliers, year == last_available_season)
```

```{r}
# Kreiranje modela na temelju podataka iz trening-seta
model_igraca <- lm(ace ~ train_data$surface + train_data$`1st serves made` + train_data$`1st serves won` + train_data$double_fault + train_data$`2nd serves won`+ train_data$`served games` , data = as.data.frame(train_data))

summary(model_igraca)

# Procjena performansi modela na test setu
predicted_aces_test <- predict(model_igraca, predicted_data = as.data.frame(test_data))
mse <- mean((test_data$ace - predicted_aces_test)^2)
sse <- ((test_data$ace - predicted_aces_test)^2)
print(paste("Mean Squared Error (MSE):", mse))
tail(paste("Squared Sum Error (SSE): ", sse))

qqnorm(residuals(model_igraca))
qqline(residuals(model_igraca))

plot(density(residuals(model_igraca)), main = "Dijagram gustoće reziduala")
```

Pogledamo li sažetak modela za Novaka Đokovića, vidimo da kod njega možemo odbaciti dvostruke pogreške iz modela, dok je broj serviranih gejmova vrlo značajan za broj aseva. Ukanjanjem tog prediktora blago povećamo vrijednost R kvadrata i MSE-a.

```{r}
# Kreiranje modela na temelju podataka iz trening-seta
model_igraca <- lm(ace ~ train_data$surface + train_data$`1st serves made` + train_data$`1st serves won` + train_data$`2nd serves won`+ train_data$`served games` , data = as.data.frame(train_data))

summary(model_igraca)
```

```{r, echo = FALSE}
# Procjena performansi modela na test setu
predicted_aces_test <- predict(model_igraca, predicted_data = as.data.frame(test_data))
mse <- mean((test_data$ace - predicted_aces_test)^2)
sse <- ((test_data$ace - predicted_aces_test)^2)
print(paste("Mean Squared Error (MSE):", mse))
tail(paste("Squared Sum Error (SSE): ", sse))

qqnorm(residuals(model_igraca))
qqline(residuals(model_igraca))

plot(density(residuals(model_igraca)), main = "Dijagram gustoće reziduala")
```

## Zaključak

Gledajući dobivene rezultate, zaključuje se da je korištenjem linearne regresije moguće dobiti broj aseva koje će igrač odservirati u tekućoj sezoni, no s relativno malom sigurnošću. U modelima dobivenima u ovom zadatku, ta se sigurnost kreće između 30 i 36 posto. Evidendno je da je model na dobrom tragu, no postoje "skriveni" prediktori koji nam nisu dostupni iz dobivenih podataka.

Pri kreiranju modela potrebno je analizirati svakog igrača zasebno. Pokazano je da prediktori koji su značajni za jednog igrača nemaju nikakvog utjecaja na broj aseva drugog, i samo narušavaju kvalitetu kreiranog modela.

# 6. istrazivačko pitanje: U kojoj je mjeri moguće predvidjeti ishod teniskog meča?

## Uvod

Kako bi odgovorili na ovo pitanje, u analizi smo se fokusirali na teniske mečeve iz perioda 2010-2020 (mečevi "modernog tenisa" za koje imamo većinu podataka za veliki broj varijabli, Novak Đoković je 2011. osvojio 3/4 Grand Slam turnira i počela je formacija tzv. "Velike trojke"...) pri čemu nećemo uzimati u obzir mečeve Olimpijskih igara, Davis Cup-a i ATP Tour Finals-a zbog drugačijeg formata (ovo su jedini turniri za koje smo našli da su drugačijeg formata, vrlo je vjerojatno da ih ima još, ali izgleda da nam nisu stvarali previše problema kasnije):

```{r}
matches <- fetch_data(2010:2020)

matches$tourney_name %>% 
  str_detect("(Olympics|Davis Cup|Finals)") %>% 
    which -> differentFormatMatchesIndices
matches <- matches[-differentFormatMatchesIndices,]
```

Za predikciju ishoda meča koristit ćemo sljedeće varijable (vrijednosti varijabli sa oznakom * izračunavamo na temelju svih mečeva tenisača koji su odigrani prije meča za koji računamo odgovarajuću statistiku):

- height - visina igrača. Viši igrači imaju brži i efikasniji servis, lakše pokrivaju teren, bolja igra na mreži.
- age - broj godina. Veći broj godina donosi iskustvo, ali potencijalno i lošije fizičke sposobnosti.
- rank - rang na ATP ljestvici. Indikator sveukupne kvalitete igrača.
- avgAce* - prosječan broj asova po meču. Indikator kvalitete servisa tenisača.
- avgDf* - prosječan broj dvostrukih pogrešaka po meču. Indikator sklonosti pogreškama.
- avgSvptWon* - prosječan omjer osvojenih poena na servisu u usporedbi s igračevim brojem odigranih poena za vlastiti servis. Indikator snažnog i efikasnog servisa.
- avgBpSavedPercentage* - prosječan omjer "spašenih" breakpointova. Indikator mentalne snage i iskustva tenisača.
- winrate* - postotak pobjeda u dosadašnjoj karijeri. Indikator kvalitete tenisača.
- lastTenWinrate - postotak pobjeda u zadnjih 10 mečeva. Indikator forme tenisača.

U nastavku slijede grafovi za neke od prethodno odabranih statistika čiji nam je utjecaj na konačan ishod meča bio "upitan":

```{r}
ifelse(matches$w_bpFaced == 0, NA, 
       matches$w_bpSaved / matches$w_bpFaced) -> wBpSavedPercentage
ifelse(matches$l_bpFaced == 0, NA, 
       matches$l_bpSaved / matches$l_bpFaced) -> lBpSavedPercentage

data <- data.frame(winner = wBpSavedPercentage, loser = lBpSavedPercentage)
data <- na.omit(data)
data <- gather(data, key = "status", value = "bpSavedPercentage")

plot <- ggplot(data, aes(x = bpSavedPercentage, fill = status)) +
  geom_histogram(alpha = 0.5, bins = 40, position = 'identity') +
  scale_fill_manual(values = c("winner" = "green", "loser" = "red")) + theme_bw()

plot
```
```{r}
ifelse(matches$w_svpt == 0, NA, 
       (matches$w_1stWon + matches$w_2ndWon) / matches$w_svpt) -> wSvptWonPercentage
ifelse(matches$l_svpt == 0, NA, 
       (matches$l_1stWon + matches$l_2ndWon) / matches$l_svpt) -> lSvptWonPercentage

data <- data.frame(winner = wSvptWonPercentage, loser = lSvptWonPercentage)
data <- na.omit(data)
data <- gather(data, key = "status", value = "svptWonPercentage")

plot <- ggplot(data, aes(status, svptWonPercentage)) +
  geom_boxplot() + theme_bw()

plot
```
```{r}
data <- data.frame(winner = matches$winner_age, loser = matches$loser_age)
data <- gather(data, key = "status", value = "age")

plot <- ggplot(data, aes(x = age, color = status)) +
  geom_density() + theme_bw()

plot
```

Iz priloženog možemo vidjeti da je naša intuicija bila na dobrom putu: svaka od prikazanih varijabli bi mogla utjecati na ishod meča. Sada ćemo izbaciti neregularne obzervacije:

```{r}
faultyDataMatchesIndices <- which(
  apply(matches[, c("winner_rank", "loser_rank", "winner_ht", "loser_ht", "w_ace")], 
        1, function(x) any(is.na(x))))
matches <- matches[-faultyDataMatchesIndices,]
```

te još malo pripremiti skup podataka za obradu:

```{r}
matches$tourney_date <- ymd(matches$tourney_date)
matches <- matches %>% arrange(tourney_date, match_num)
matches$match_id <- seq(1, nrow(matches))
```

## Obrada skupa podataka

Sada odabiremo one teniske mečeve na kojima ćemo kasnije bazirati naš logistički model. To su teniski mečevi u kojima je svaki od oba tenisača prethodno odigrao barem 10 mečeva (pojedine statistike kao što je npr. winrate su jako osjetljive na broj obzervacija). Ove mečeve ćemo u nastavku zvati "validni mečevi":

```{r}
checkIfValidForProcessing = function(match) {
  winnerId <-  match["winner_id"] %>% as.numeric
  loserId <-  match["loser_id"] %>% as.numeric
  matchId <-  match["match_id"] %>% as.numeric
  
  lastMatchIndex <-  matchId - 1
  if (lastMatchIndex == 0) return(FALSE)
  
  winnersCandidates <-  pull(matches[1:lastMatchIndex, ], winner_id)
  losersCandidates <-  pull(matches[1:lastMatchIndex, ], loser_id)
  playersCandidates <-  c(winnersCandidates, losersCandidates)
  
  validPlayersIndices <-  table(playersCandidates) >= 10
  table(playersCandidates)[validPlayersIndices] %>% names %>% as.numeric -> validPlayers
  
  if (winnerId %in% validPlayers && loserId %in% validPlayers) return (TRUE)
  
  return (FALSE)
}

validMatchesIndices <- apply(matches, 1, checkIfValidForProcessing)
validMatches <- matches[validMatchesIndices, ]
```

Sada kreiramo pomoćni podatkovni okvir u kojemu će jedna obzervacija predstavljati statistike pojedinog igrača po pojedinom meču. NAPOMENA: ovdje gledamo performanse svakog igrača, i pobjednika i gubitnika, na svakom meču iz perioda 2010-2020 (osim na onim mečevima koje smo izbacili nakon prvog "čišćenja"):

```{r}
allWinnersMatchStats <- matches[, c("match_id", "winner_id", "w_ace", "w_df", "w_svpt", 
                                    "w_1stWon", "w_2ndWon", "w_bpSaved", "w_bpFaced")]
allWinnersMatchStats$won <- 1
names(allWinnersMatchStats) <- c("matchId", "playerId", "ace", "df", "svpt", 
                                 "firstWon", "secondWon", "bpSaved", "bpFaced", "won")

allLosersMatchStats <- matches[, c("match_id", "loser_id", "l_ace", "l_df", "l_svpt",
                                   "l_1stWon", "l_2ndWon", "l_bpSaved", "l_bpFaced")]
allLosersMatchStats$won <- 0
names(allLosersMatchStats) <- c("matchId", "playerId", "ace", "df", "svpt",
                                "firstWon", "secondWon", "bpSaved", "bpFaced", "won")

allPlayersMatchStats <- rbind(allWinnersMatchStats, allLosersMatchStats)
allPlayersMatchStats <- allPlayersMatchStats %>% arrange(matchId)
```

Kreiramo dva podatkovna okvira (jedan za pobjednika, drugi za gubitnika) koji će sadržavati podatke o godinama, visini i rangu na ATP ljestvici u trenutku igranja validnog meča:

```{r}
validMatchesWinnerInfo <- validMatches[, c("match_id", "winner_id", "winner_ht", 
                                           "winner_age", "winner_rank")]
names(validMatchesWinnerInfo) <- c("matchId", "playerId", "height", "age", "rank")

validMatchesLoserInfo <- validMatches[, c("match_id", "loser_id", "loser_ht", 
                                          "loser_age", "loser_rank")]
names(validMatchesLoserInfo) <- c("matchId", "playerId", "height", "age", "rank")
```

Za svaki validni meč računamo potrebne statistike za tenisača pobjednika i tenisača gubitnika na temelju svih njihovih prethodnih mečeva koji se nalaze u skupu "matches":

```{r}
calculateValidMatchesStats <- function(x) {
  
  matchId = x["matchId"] %>% as.numeric
  playerId = x["playerId"] %>% as.numeric
  height = x["height"] %>% as.numeric 
  age = x["age"] %>% as.numeric 
  rank = x["rank"] %>% as.numeric 
  
  pastMatches <- allPlayersMatchStats[allPlayersMatchStats$playerId == playerId & 
                                        allPlayersMatchStats$matchId < matchId,]
  
  avgAce <- mean(pastMatches$ace, na.rm = T) 
  
  avgDf <- mean(pastMatches$df, na.rm = T)

  svptWonPercentage <- ifelse(pastMatches$svpt == 0, NA, 
                              (pastMatches$firstWon + pastMatches$secondWon) / pastMatches$svpt)
  avgSvptWonPercentage <- mean(svptWonPercentage, na.rm = T)
  
  bpSavedPercentage <- ifelse(pastMatches$bpFaced == 0, NA, 
                              pastMatches$bpSaved / pastMatches$bpFaced)
  avgBpSavedPercentage <- mean(bpSavedPercentage, na.rm = T)
                              
  winrate <- mean(pastMatches$won, na.rm = T)
  
  lastTenWinrate <- sum(tail(pastMatches$won, 10)) / 10

  result <- c(matchId, height, age, rank, avgAce, avgDf, 
              avgBpSavedPercentage, avgSvptWonPercentage, winrate, lastTenWinrate)
  
  result
}

validMatchesWinnerData <- apply(validMatchesWinnerInfo, 1, calculateValidMatchesStats)
validMatchesWinnerData <- as.data.frame(t(validMatchesWinnerData))
colnames(validMatchesWinnerData) <- c("matchId", "height", "age", "rank", "avgAce", "avgDf", "avgBpSavedPercentage", "avgSvptWonPercentage", "winrate", "lastTenWinrate")

validMatchesLoserData <- apply(validMatchesLoserInfo, 1, calculateValidMatchesStats)
validMatchesLoserData <- as.data.frame(t(validMatchesLoserData))
colnames(validMatchesLoserData) <- c("matchId", "height", "age", "rank", "avgAce", "avgDf", "avgBpSavedPercentage", "avgSvptWonPercentage", "winrate", "lastTenWinrate")

```

Stvaramo 3 nova podatkovna okvira: playerOne, playerTwo i playerDifference. Prva 2 podatkovna okvira odgovaraju jedan drugom po retcima, npr. u oba okvira u retku 547 se nalaze podaci o istom meču, samo jedan od njih sadrži sve podatke o gubitniku, a drugi o pobjedniku, s tim da je okvir koji sadrži podatke za pobjednika, odnosno gubitnika, nasumično odabran. Okvir playerDifference predstavlja njihovu razliku:

```{r}
winnerIndices <- sample(1:23101, size = length(1:23101) * 0.5, replace = FALSE)

playerOne <- rbind(validMatchesWinnerData[winnerIndices, ], 
                   validMatchesLoserData[-winnerIndices, ]) %>% arrange(matchId)
playerTwo <- rbind(validMatchesWinnerData[-winnerIndices, ], 
                   validMatchesLoserData[winnerIndices, ]) %>% arrange(matchId)
playerDifference <- playerOne - playerTwo

playerDifference$won <- 0
playerDifference[winnerIndices, "won"] <- 1
playerDifference$matchId <- NULL

head(playerDifference, 5)
```

Još je samo potrebno normalizirati podatke:

```{r}
normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}
playerDifference <- as.data.frame(lapply(playerDifference, normalize))

head(playerDifference, 5)
```

## Treniranje modela, predikcija i zaključak

Dijelimo obzervacije u skupove podataka za treniranje i predikciju:

```{r}
set.seed(123)

trainingIndices <- sample(1:nrow(playerDifference), nrow(playerDifference) * 0.7)
trainingSet <- playerDifference[trainingIndices, ]
testingSet <- playerDifference[-trainingIndices, ]
```

Provodimo logističku regresiju:

```{r}
model <- glm(won ~ ., family = binomial(link = "logit"), data = trainingSet)
```

Sada pogledajmo ispis rezultata našeg modela:

```{r}
summary(model)
```

Za početak bacimo pogled na stupac s imenom "Pr(>|z|)" koji nam ukazuje na to koje su se od varijabli u našem modelu pokazale statistički značajnim: za svaku varijablu nam daje P-vrijednost testa hipoteze da je pripadni koeficijent jednak 0. Možemo zaključiti da su nam za razinu značajnosti od 0.05 statistički značajne sve varijable osim height, avgDf i avgBpSavedPercentage koje ne doprinose efikasnosti modela. Sada pogledajmo koliko je naš model dobar: 

```{r}
predictions <- predict(model, newdata = testingSet, type = "response")
predictions <- ifelse(predictions > 0.5, 1, 0)

misClasificError <- mean(predictions != testingSet$won)
print(paste('Accuracy', 1 - misClasificError))
```

Preciznost od 66.3973% na skupu podataka od 6931 obzervacija. Ajmo sada opet provesti logističku regresiju, ali bez prethodno spomenutih varijabli:

```{r}
set.seed(123)

indices <- c(2, 3, 4, 7, 8, 9, 10)
playerDifference <- playerDifference[, indices]
trainingIndices <- sample(1:nrow(playerDifference), nrow(playerDifference) * 0.7)
trainingSet <- playerDifference[trainingIndices, ]
testingSet <- playerDifference[-trainingIndices, ]
model <- glm(won ~ ., family = binomial(link = "logit"), data = trainingSet)
summary(model)
```

AIC vrijednost je sada malo manja, što je indikator da je ovaj model bolji. Da vidimo koliko je zapravo dobar:

```{r}
predictions <- predict(model, newdata = testingSet, type = "response")
predictions <- ifelse(predictions > 0.5, 1, 0)

misClasificError <- mean(predictions != testingSet$won)
print(paste('Accuracy', 1 - misClasificError))
```

Sada nam je preciznost još manja ("Dikod uđe, dikod ne uđe" - Mate Baturina). Međutim, unatoč tome možemo zaključiti da je itekako moguće predvidjeti ishod teniskog meča pomoću logističke regresije.

# 7. istraživačko pitanje: Postoji li razlika u broju odigranih aseva između igrača koji su osvojili Grand Slam naslov i onih koji nisu?

## Učitavanje podataka

Podatke ćemo učitati iz CSV datoteka u listu podatkovnih okvira. Svaki podatkovni okvir sadržava podatke mečeva jedne godine. Nakon toga spajamo sve podatkove okvire u jedan te time imamo informacije o svim odigranim mečevima od 1968. do 2023. godine dostupne u jednom podatkovnom okviru. Iz tog okvira ćemo naknadno izvlačiti potrebne podatke za svrhe analize.

Proces učitavanja podataka je prikazan u sljedećem bloku koda:

```{r}
matches <- fetch_data(1968:2023)
```

## Prilagodba tipova podataka

Nakon učitavanja podataka, potrebno je ispraviti tipove podataka za neke stupce. Ti stupci su:

* `surface` - podloga na kojoj se igrao meč: trava, zemlja, tvrda podloga, tepih (eng. grass, clay, hard, carpet)
* `tourney_level` - razina turnira: Grand Slam, ATP Finals, ATP Masters 1000, ATP Tour, ATP Challengers
* `tourney_date` - datum održavanja turnira
* `winner_hand` - ruka s kojom je pobjednik igrao meč: desnoruk, lijevoruk, ambidekster, nepoznato (eng. right-handed ("R"), left-handed ("L"), ambidextrous ("A"), unknown ("U"))
* `loser_hand` - ruka s kojom je gubitnik igrao meč (definirano isto kao i za winner_hand)

Prilagodba tipova podataka je prikazana u sljedećem kodu:

```{r}
matches$surface <- factor(
  matches$surface,
  levels = c("Grass", "Clay", "Hard", "Carpet")
)
matches$tourney_level <- factor(
  matches$tourney_level,
  levels = c("F", "A", "D", "M", "G")
)
matches$tourney_date <- ymd(matches$tourney_date)
matches$winner_hand <- factor(
  matches$winner_hand,
  levels = c("R", "L", "A", "U")
)
matches$loser_hand <- factor(
  matches$loser_hand,
  levels = c("R", "L", "A", "U")
)
```

## Statistička analiza

### Priprema podataka
Potrebne su nam dvije glavne grupe u koje ćemo podijeliti igrače:

* igrači s barem jednom osvojenom Grand Slam titulom
* igrači bez osvojene Grand Slam titule (u daljnjem tekstu ćemo ih nazvati "ostali igrači")

Uz te dvije glavne grupe, stvorit ćemo dodatnu grupu za ostale igrače gdje ih dodatno filtriramo tako da uklonimo igrače koji su ukupno sudjelovali u manje od 7 mečeva. Budući da uspoređujemo prosjeke odigranih asova po meču, želimo izbjeći situacije gdje bi igrači koji su odigrali samo jedan ili dva meča imali velik utjecaj na prosjek cijele grupe. Budući da je za osvajanje titule potrebno odigrati i pobijediti u barem 7 mečeva (za grand slam turnire se inicijalno izvlači 128 sudionika), smatramo da je 7 mečeva minimalna granica koju igrač mora ispuniti da bi bio uključen u usporedbu s igračima koji su osvojili Grand Slam titulu. U daljnjem tekstu ćemo se na tu grupu referirati kao "ostali igrači (n>=7)" i odvojeno ju uspoređivati s igračima koji su osvojili Grand Slam titulu.

Proces izvlačenja i pripreme podataka je prikazan i komentiran u sljedećem bloku koda:

```{r}
# izrada novog okvira s podatcima o svim igračima (ID, ime, broj asova)
all_players <- matches %>%
  dplyr::select(winner_id, winner_name, w_ace) %>%
  rename(id = winner_id, name = winner_name, aces = w_ace) %>%
  bind_rows(matches %>%
    dplyr::select(loser_id, loser_name, l_ace) %>%
    rename(id = loser_id, name = loser_name, aces = l_ace))

# uklanjanje unosa za koje ne postoje podatci o broju odigranih asova
all_players <- all_players %>%
  filter(!is.na(aces))

# grupiranje igrača po ID-u i imenu te izračun prosjeka asova po meču (APM)
all_players <- all_players %>%
  group_by(id, name) %>%
  summarise(aces = sum(aces), matches = n()) %>%
  mutate(apm = aces / matches)

# filtriranje igrača koji su odigrali >=7 mečeva
filter_players <- all_players %>%
  filter(matches >= 7)

# izrada okvira za igrače s naslovom (pobjeda u finalu Grand Slam turnira)
gs_winners <- matches %>%
  filter(tourney_level == "G" & round == "F") %>%
  dplyr::select(winner_id, winner_name) %>%
  rename(id = winner_id, name = winner_name) %>%
  distinct(id, name)

# dodavanje stupca s prosjekom asova po meču (apm) za igrače s naslovom
gs_winners <- gs_winners %>%
  left_join(all_players, by = c("id", "name")) %>%
  filter(!is.na(apm))

# izrada okvira za ostale igrače (bez naslova)
gs_others <- all_players %>%
  filter(!id %in% gs_winners$id)

# izrada okvira za ostale igrače uz uvjet da su odigrali barem 7 mečeva
gs_filter1 <- filter_players %>%
  filter(!id %in% gs_winners$id)

# brisanje privremenih okvira koji su nepotrebni u daljnjem radu
rm(filter_players)
```

### Deskriptivna statistika

Sada kada imamo podatke na kojima možemo provoditi analizu, izračunat ćemo osnovne deskriptivne statistike za svaku od grupa. Izračunat ćemo sljedeće vrijednosti:

* prosjek asova svake grupe
* medijan asova
* standardnu devijaciju asova
* minimalnu vrijednost asova svake grupe
* maksimalnu vrijednost asova svake grupe
* ukupan broj odigranih mečeva za svaku grupu
* prosjek asova po meču (APM) cijele grupe
* broj igrača u svakoj grupi

```{r echo=FALSE}
# ispis deskriptivne statistike asova za svaku grupu
gs_winners %>%
  mutate(id = "Grand Slam pobjednici") %>%
  bind_rows(gs_others %>%
    mutate(id = "Ostali igrači")) %>%
  bind_rows(gs_filter1 %>%
    mutate(id = "Ostali igrači (n>=7)")) %>%
  bind_rows(all_players %>%
    mutate(id = "Svi igrači")) %>%
  group_by(id) %>%
  summarise(
    mean_aces = mean(aces),
    median_aces = median(aces),
    sd_aces = sd(aces),
    min_aces = min(aces),
    max_aces = max(aces),
    total_matches = sum(matches),
    group_apm = sum(aces) / sum(matches),
    n_players = n()
  ) %>%
  knitr::kable(
    caption = "Servirani asovi po grupama",
    digits = 2
  )
```

Uz tablicu s deskriptivnim statistikama, možemo i vizualizirati podatke kako bismo dobili bolji uvid u njih. Za to ćemo koristiti boxplotove za broj asova i srednje vrijednost asova po mečevima (APM) igrača te dijagrame gustoće za prosjek asova po meču kako bismo dobili uvid u distribuciju podataka. Za svaku od grupa ćemo izraditi zasebne vizualizacije kako bismo mogli usporediti podatke između grupa. Uz to, izradit ćemo i vizualizacije za sve igrače kako bismo dobili uvid u distribuciju podataka za cijelu populaciju igrača.

Boxplotovi broja asova i APM-ova za svaku grupu:

```{r, echo=FALSE}
# izrada boxplot dijagrama za broj asova svake grupe
ggplot() +
  geom_boxplot(data = gs_winners, aes(x = aces, y = "Grand Slam pobjednici")) +
  geom_boxplot(data = gs_others, aes(x = aces, y = "Ostali igrači")) +
  geom_boxplot(data = gs_filter1, aes(x = aces, y = "Ostali igrači (n>=7)")) +
  geom_boxplot(data = all_players, aes(x = aces, y = "Svi igrači")) +
  labs(x = "Broj asova", y = "Grupa igrača") +
  theme_bw()

# izrada boxplot dijagrama APM-ova svake grupe
ggplot() +
  geom_boxplot(data = gs_winners, aes(x = apm, y = "Grand Slam pobjednici")) +
  geom_boxplot(data = gs_others, aes(x = apm, y = "Ostali igrači")) +
  geom_boxplot(data = gs_filter1, aes(x = apm, y = "Ostali igrači (n>=7)")) +
  geom_boxplot(data = all_players, aes(x = apm, y = "Svi igrači")) +
  labs(x = "APM igrača", y = "Grupa igrača") +
  theme_bw()
```

Iz boxplot dijagrama možemo vidjeti kako je distribucija asova igrača jako nakošena na lijevu stranu te kako ima jako puno ekstremnih vrijednosti, što i ima smisla jer broj asova ultimativno ovisi o ukupnom broju mečeva koje je igrač odigrao tijekom svoje karijere.

Zbog toga ćemo usporedbu broja asova između grupa raditi kroz srednju vrijednost asova po mečevima (APM) igrača. Kroz APM dobivamo jedinstvenu mjeru koja ne ovisi o broju mečeva koje je igrač odigrao te je stoga pogodnija za usporedbu između grupa.

U boxplot dijagramu APM-ova možemo stoga primijetiti kako su distribucije APM-ova puno manje nakošene te imaju puno manje ekstremnih vrijednosti.

Deskriptivna statistika APM-ova za svaku grupu je sljedeća:

```{r, echo=FALSE}
# ispis deskriptivne statistike APM-ova za svaku grupu
gs_winners %>%
  mutate(id = "Grand Slam pobjednici") %>%
  bind_rows(gs_others %>%
    mutate(id = "Ostali igrači")) %>%
  bind_rows(gs_filter1 %>%
    mutate(id = "Ostali igrači (n>=7)")) %>%
  bind_rows(all_players %>%
    mutate(id = "Svi igrači")) %>%
  group_by(id) %>%
  summarise(
    mean_apm = mean(apm),
    median_apm = median(apm),
    sd_apm = sd(apm),
    min_apm = min(apm),
    max_apm = max(apm),
    n_players = n()
  ) %>%
  knitr::kable(
    caption = "APM igrača po grupama",
    digits = 3
  )
```

Kako bismo dobili bolji uvid u samu distribuciju APM-ova grupa, izradit ćemo dijagrame gustoće za svaku grupu:

```{r, echo=FALSE}
# izrada grafova gustoće APM-ova za svaku grupu
gs_winners %>%
  mutate(id = "Grand Slam pobjednici") %>%
  bind_rows(gs_others %>%
    mutate(id = "Ostali igrači")) %>%
  bind_rows(gs_filter1 %>%
    mutate(id = "Ostali igrači (n>=7)")) %>%
  bind_rows(all_players %>%
    mutate(id = "Svi igrači")) %>%
  ggplot(aes(x = apm, fill = id)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~id, ncol = 2) +
  labs(x = "APM igrača", y = "Gustoća igrača za APM") +
  theme_bw()
```

Iz dijagrama gustoća svake od grupa možemo vidjeti kako su podatci uistinu još uvijek lijevo nakošeni te vjerojatno nisu normalno distribuirani. Zbog toga ćemo prvo trebati provjeriti normalnost podataka kako bismo mogli odlučiti koje testove ćemo koristiti za usporedbu grupa.

### Statističko testiranje

Nakon vizualnog uvida u podatke i izračunatih deskriptivnih statistika, možemo započeti statističko testiranje kako bismo dobili odgovor na temeljno pitanje ovog istraživanja: ***Postoji li razlika u broju odigranih aseva između igrača koji su osvojili Grand Slam naslov i onih koji nisu?***

#### Normalnost uzoraka

Kako bismo odlučili hoćemo li koristiti parametarske ili neparametarske testove, potrebno je provjeriti normalnost podatako. Za to ćemo iskoristiti Kolmogorov-Smirnovljev test. Budući da smo već ranije zaključili da je APM pogodniji za usporedbu grupa, provjerit ćemo normalnost samo za APM-ove.

Prije provođenja Kolmogorov-Smirnovljevog testa postavljamo sljedeće hipoteze:

* H0: Podatci su normalno distribuirani
* H1: Podatci nisu normalno distribuirani

Za test uzimamo razinu značajnosti od 0.05.

```{r, echo=FALSE, warning=FALSE}
# provjera normalnosti APM-ova za svaku grupu i vizualizacija
ggplot(
  data = gs_winners,
  aes(x = apm)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(gs_winners$apm), sd = sd(gs_winners$apm)),
    color = "red"
  ) +
  labs(x = "APM igrača", y = "CDF") +
  ggtitle("Grand Slam pobjednici") +
  theme_bw()

ks.test(
  gs_winners$apm,
  "pnorm",
  mean = mean(gs_winners$apm),
  sd = sd(gs_winners$apm),
  exact = TRUE
)

ggplot(
  data = gs_others,
  aes(x = apm)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(gs_others$apm), sd = sd(gs_others$apm)),
    color = "red"
  ) +
  labs(x = "APM igrača", y = "CDF") +
  ggtitle("Ostali igrači") +
  theme_bw()

ks.test(
  gs_others$apm,
  "pnorm",
  mean = mean(gs_others$apm),
  sd = sd(gs_others$apm),
  exact = TRUE
)

ggplot(
  data = gs_filter1,
  aes(x = apm)
) +
  stat_ecdf(geom = "step", pad = FALSE) +
  stat_function(
    fun = pnorm,
    args = list(mean = mean(gs_filter1$apm), sd = sd(gs_filter1$apm)),
    color = "red"
  ) +
  labs(x = "APM igrača", y = "CDF") +
  ggtitle("Ostali igrači (n>=7)") +
  theme_bw()

ks.test(
  gs_filter1$apm,
  "pnorm",
  mean = mean(gs_filter1$apm),
  sd = sd(gs_filter1$apm),
  exact = TRUE
)
```

Kao što možemo vidjeti iz dijagrama i rezultata Kolmogorov-Smirnovljevog testa, jedino uzorak igrača s Grand Slam naslovom prolazi test normalnosti, dok ostali, zbog činjenice da su uzorci puno veći, ne prolaze test te za njih odbacujemo H0 hipotezu uz razinu značajnosti od 0.05.

Zbog toga ćemo morati koristiti neparametarske testove za usporedbu grupa.

#### Neparametarsko testiranje

Sada kada smo utvrdili da su uzorci nenoormalno distribuirani, možemo koristiti neparametarske testove za usporedbu grupa. Budući da uspoređujemo dvije grupe, koristit ćemo Mann-Whitney U test. Prije provođenja testa postavljamo sljedeće hipoteze:

* H0: Nema razlike u prosjeku APM-ova između grupa (uzorci dolaze iz iste populacije)
* H1: Postoji razlika u prosjeku APM-ova između grupa (jedan uzorak stohastički dominira)

Za ovaj test također uzimamo razinu značajnosti od 0.05.
  
```{r, echo=FALSE}
# provođenje Mann-Whitney U testa između igrača s naslovom i ostalih igrača
wilcox.test(
  gs_winners$apm,
  gs_others$apm,
  alternative = "two.sided",
  paired = FALSE,
  exact = FALSE,
  correct = TRUE
)

# provođenje Mann-Whitney U testa između igrača s naslovom i ostalih igrača (n>=7)
wilcox.test(
  gs_winners$apm,
  gs_filter1$apm,
  alternative = "two.sided",
  paired = FALSE,
  exact = FALSE,
  correct = TRUE
)
```

Kao što možemo vidjeti iz rezultata testa, u oba slučaja odbacujemo H0 hipotezu uz razinu značajnosti od 0.05. To znači da postoji razlika u prosjeku APM-ova između grupa igrača s osvojenim Grand Slam naslovom i ostalih igrača. Uz to, možemo primijetiti kako je razlika u prosjeku APM-ova između uzorka igrača s naslovom i ostalih igrača puno veća nego između uzorka igrača s naslovom i filtriranih ostalih igrača.

## Zaključak

U ovom istraživanju smo pokušali odgovoriti na pitanje postoji li razlika u broju odigranih aseva između igrača koji su osvojili Grand Slam naslov i onih koji nisu. Kako bismo odgovorili na to pitanje, analizirali smo podatke o svim odigranim mečevima od 1968. do 2023. godine. Nakon pripreme podataka, izračunavanja deskriptivnih statistika i vizualizacije podataka, zaključili smo da postoji razlika u prosjeku APM-ova između igrača koji su osvojili Grand Slam naslov i onih koji nisu. Uz to, možemo primijetiti kako je razlika u prosjeku APM-ova između uzorka igrača s naslovom i ostalih igrača puno veća nego između uzorka igrača s naslovom i filtriranih ostalih igrača. Iz toga možemo zaključiti da postoji razlika u broju odigranih aseva između igrača koji su osvojili Grand Slam naslov i onih koji nisu te da je ta razlika puno veća nego što se može objasniti činjenicom da igrači koji su osvojili Grand Slam naslov imaju više odigranih mečeva od ostalih igrača. Iz toga možemo zaključiti da bi broj odigranih aseva mogao biti jedan od faktora koji utječu na osvajanje Grand Slam naslova.

```{r, echo=FALSE, include=FALSE}
# oslobađanje memorije
rm(all_players, gs_winners, gs_others, gs_filter1)
```
